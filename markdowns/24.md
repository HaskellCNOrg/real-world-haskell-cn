# 第二十四章 并发编程和多核编程

在我们书写本书时，CPU的架构正在经历着比过去十年更加迅速的变化。

## 并发和并行的定义

一个*并发*程序需要在同一时间运行一些彼此可能毫无关系的任务。想象一个游戏服务器作为例子：它通常由几十个组件构成的，每个组件和外部世界有很复杂的交互。一个组件可能处理多用户聊天；另外会有几个处理用户的输入并更新状态；同时还有会其他的组件进行一些物理计算。

并发程序的一个正确操作并需要多核，尽管多核可能会提高性能以及响应时间。

与此不同的，并行程序是解决某一个特定的问题。比如有这样一个财务模型，它尝试预测下一分钟某支股票的波动情况。如果我们尝试将这个模型应用于交易所的所有股票，比方说要估计应该如何买卖，我们期望当程序运行在五百核的机子上将比运行单核的机子上更快的得到答案。因此，并行程序通常并需要在多核的情况下也能正确运行。

并发和并行另外一个有用的区别是在于它们是如何和外界交互的。根据定义，并发程序是持续的和网络、协议、数据库等交互。而一个典型的并行程序通常更加专注：输入数据，处理（略带IO的操作），输出结果。

众多传统的编程语言并没有明显的区分并发和并行，因为它们强制程序员使用同样的基础元素构建这两类程序。

在本章中，我们会关注在基于单操作系统线程模型的并发和并行程序。

## 使用线程的并发编程

为了构建并发程序，大多数编程语言采用建立一些独立控制线程的方式。Haskell也不例外，尽管Haskell的线程编程看起来和其他语言有些不一样。

Haskell里的线程是一个`IO`操作，这个操作独立于其他线程。我们可以用模块`Control.Concurrent`的`forkIO`函数新建一个线程。

~~~~~{.sh}
ghci> :m +Control.Concurrent
ghci> :t forkIO
forkIO :: IO () -> IO ThreadId
ghci> :m +System.Directory
ghci> forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy"
False
~~~~~

[译者注： 上述的运行结构最后可能是 `True`。这是正常的，请继续往下看。]

新生成的线程几乎马上会执行，生成新线程的主线程会同步执行。当到达`IO`操作完成时线程停止。

### 线程是非确定性(nondeterministic)

GHC运行时组件不会指定线程运行顺序。因此上述的例子中，当原始线程检查新线程所创建的文件`xyzzy`时，这个文件可能已存在，可能不存在。如果我们运行了这个例子一次，然后删除文件`xyzzy`，再运行一次程序，就可能得到不一样的结果。

### 隐藏延时

假设

## 简单的线程间通讯

## 主线程以及等待其他线程

### 安全的修改MVar变量
### 安全资源管理：一个好主意
### 查找线程的状态
### 更加严谨的代码

## 基于Channel的通讯

## 更多有用的知识
### MVar和Chan是非严格的(Non-Strict)
### Chan是非绑定的

## 共享状态的并发还是很难
### 死锁
### 饥饿
### 还有希望吗？

## 练习

## 基于GHC的多核
### 运行时选项
### 在Haskell代码里查看核的数量
### 选择正确的运行时

## Haskell里的并发
### Normal form 和 Head normal form
### 顺序排序
### 转换为有并行特性的代码
### 并行时是如何求值得
### par函数能带来什么样的保证
### 性能评估
### 性能调优
### 练习

## 并发策略和MapReduce
### 分离算法和求值
### 分离算法和策略
### 简单的MapReduce定义
### Sizing work appropriately
#### Mitigating the risks of lazy IO
### 有效地寻找 line-aligned chunks
### 计算行数
### 查找最流行的链接
### 总结

